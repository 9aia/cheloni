import{_ as a,o as t,c as s,ai as n}from"./chunks/framework.Bm4BMKaq.js";const m=JSON.parse('{"title":"How Manifest Works","description":"","frontmatter":{},"headers":[],"relativePath":"explanation/how-it-works/core/manifest.md","filePath":"explanation/how-it-works/core/manifest.md"}'),o={name:"explanation/how-it-works/core/manifest.md"};function i(r,e,d,c,l,p){return t(),s("div",null,[...e[0]||(e[0]=[n(`<h1 id="how-manifest-works" tabindex="-1">How Manifest Works <a class="header-anchor" href="#how-manifest-works" aria-label="Permalink to “How Manifest Works”">​</a></h1><p>How metadata is extracted from definitions for help generation and introspection.</p><h2 id="what-the-manifest-contains" tabindex="-1">What the Manifest Contains <a class="header-anchor" href="#what-the-manifest-contains" aria-label="Permalink to “What the Manifest Contains”">​</a></h2><p>Each definition type has a corresponding manifest interface that holds only serializable metadata — no Zod schemas, no handlers, no runtime logic.</p><ul><li><strong>CLI</strong>: name, version, description, details, deprecated, plus nested command/option/plugin manifests</li><li><strong>Command</strong>: name, paths, description, details, example, deprecated, plus nested positional/options/plugins/subcommand manifests</li><li><strong>Option</strong>: name, description, details, aliases, deprecated</li><li><strong>Positional</strong>: description, details, deprecated</li><li><strong>Plugin</strong>: name</li></ul><h2 id="zod-internals" tabindex="-1">Zod Internals <a class="header-anchor" href="#zod-internals" aria-label="Permalink to “Zod Internals”">​</a></h2><p>Cheloni reads metadata directly from Zod&#39;s internal <code>_def</code> property. The helper functions in <code>lib/zod.ts</code> handle the extraction:</p><ul><li><strong><code>getSchemaObject(schema)</code></strong> — unwraps a Zod object to get its <code>shape</code> (the <code>{ key: ZodType }</code> map). Tries <code>_def.shape</code> first, falls back to <code>schema.shape</code>.</li><li><strong><code>getSchemaDescription(schema)</code></strong> — reads <code>_def.description</code> or <code>_def.metadata.description</code></li><li><strong><code>getSchemaAliases(schema)</code></strong> — reads <code>_def.metadata.aliases</code> (string array)</li><li><strong><code>getSchemaDeprecated(schema)</code></strong> — reads <code>_def.deprecated</code> or <code>_def.metadata.deprecated</code> (boolean or string)</li></ul><p>These are the same internals that Zod populates when the user calls <code>.describe()</code>, <code>.meta()</code>, or <code>.deprecated()</code>.</p><h2 id="recursive-extraction" tabindex="-1">Recursive Extraction <a class="header-anchor" href="#recursive-extraction" aria-label="Permalink to “Recursive Extraction”">​</a></h2><p>Manifest extraction is recursive. <code>getCliManifest()</code> calls <code>getCommandManifest()</code> for the root command, which in turn calls itself for each nested subcommand, and calls <code>getOptionsManifest()</code> / <code>getPositionalManifest()</code> for its schemas.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>getCliManifest()</span></span>
<span class="line"><span>  ├─ getCommandManifest(rootCommand)</span></span>
<span class="line"><span>  │   ├─ getPositionalManifest()</span></span>
<span class="line"><span>  │   ├─ getOptionsManifest()</span></span>
<span class="line"><span>  │   │   └─ getOptionManifest() per field in the Zod object shape</span></span>
<span class="line"><span>  │   ├─ getPluginsManifest()</span></span>
<span class="line"><span>  │   └─ getCommandManifest() per subcommand (recursive)</span></span>
<span class="line"><span>  ├─ getOptionManifest() per global option</span></span>
<span class="line"><span>  └─ getPluginManifest() per plugin</span></span></code></pre></div><h2 id="when-it-runs" tabindex="-1">When It Runs <a class="header-anchor" href="#when-it-runs" aria-label="Permalink to “When It Runs”">​</a></h2><p>Manifest extraction happens at two points:</p><ol><li><strong>During creation</strong> — <code>createCli()</code> calls <code>getCliManifest()</code> to build the top-level manifest. <code>createCommand()</code> calls <code>getCommandManifest()</code> for each command. The extracted manifests are stored on the runtime objects (<code>cli.manifest</code>, <code>command.manifest</code>).</li><li><strong>During error handling</strong> — <code>handleError()</code> calls <code>getOptionsManifest()</code> and <code>getPositionalManifest()</code> to enrich validation error messages with field descriptions from the schema.</li></ol><p>The manifest is a snapshot. If plugins mutate the CLI structure during <code>onInit</code>, the manifest on <code>cli.manifest</code> reflects the state <em>before</em> those mutations (it&#39;s extracted first). Individual command manifests created after mutation will reflect the updated structure.</p>`,16)])])}const f=a(o,[["render",i]]);export{m as __pageData,f as default};
