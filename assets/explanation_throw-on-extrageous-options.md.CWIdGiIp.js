import{_ as o,o as a,c as t,ai as r}from"./chunks/framework.Bm4BMKaq.js";const u=JSON.parse('{"title":"extrageousOptionsBehavior Design","description":"","frontmatter":{},"headers":[],"relativePath":"explanation/throw-on-extrageous-options.md","filePath":"explanation/throw-on-extrageous-options.md"}'),s={name:"explanation/throw-on-extrageous-options.md"};function i(n,e,h,l,d,c){return a(),t("div",null,[...e[0]||(e[0]=[r('<h1 id="extrageousoptionsbehavior-design" tabindex="-1"><code>extrageousOptionsBehavior</code> Design <a class="header-anchor" href="#extrageousoptionsbehavior-design" aria-label="Permalink to “extrageousOptionsBehavior Design”">​</a></h1><h2 id="why-three-behaviors" tabindex="-1">Why Three Behaviors <a class="header-anchor" href="#why-three-behaviors" aria-label="Permalink to “Why Three Behaviors”">​</a></h2><p>A boolean forces a false dichotomy. Real-world CLI tools need:</p><ul><li><code>&#39;throw&#39;</code>: Strict validation for most commands</li><li><code>&#39;filter-out&#39;</code>: Silently ignore extras when they&#39;re harmless</li><li><code>&#39;pass-through&#39;</code>: Forward options to underlying tools in wrappers</li></ul><p>These are fundamentally different behaviors, not just &quot;strict&quot; vs &quot;permissive&quot;.</p><h2 id="why-throw-default" tabindex="-1">Why <code>&#39;throw&#39;</code> (Default) <a class="header-anchor" href="#why-throw-default" aria-label="Permalink to “Why &#39;throw&#39; (Default)”">​</a></h2><p><strong>Fail-Safe</strong>: Prevents mistakes by catching typos and invalid options early.</p><p><strong>Schema as Contract</strong>: The options schema defines what a command accepts. Extra options violate this contract.</p><p><strong>Explicit Opt-In</strong>: Choosing <code>&#39;filter-out&#39;</code> or <code>&#39;pass-through&#39;</code> is a conscious decision that makes intent clear.</p><h2 id="why-filter-out" tabindex="-1">Why <code>&#39;filter-out&#39;</code> <a class="header-anchor" href="#why-filter-out" aria-label="Permalink to “Why &#39;filter-out&#39;”">​</a></h2><p>Discards extra options silently before they reach the handler. Useful when extras are harmless noise or future-proofing, but you don&#39;t need to forward them.</p><h2 id="why-pass-through" tabindex="-1">Why <code>&#39;pass-through&#39;</code> <a class="header-anchor" href="#why-pass-through" aria-label="Permalink to “Why &#39;pass-through&#39;”">​</a></h2><p>Preserves extra options for the handler. Essential for CLI wrappers that forward options to underlying tools, which do their own validation. This is also essential for tools that accept arbitrary user-defined options—filtering or throwing would block valid, user-intended data from reaching the handler.</p><h2 id="why-per-command" tabindex="-1">Why Per-Command <a class="header-anchor" href="#why-per-command" aria-label="Permalink to “Why Per-Command”">​</a></h2><p>Commands have different semantic needs. A wrapper needs pass-through; a strict validator needs throw. Per-command configuration allows each to express its requirements without forcing a global policy.</p>',15)])])}const f=o(s,[["render",i]]);export{u as __pageData,f as default};
