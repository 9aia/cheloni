import{_ as o,o as i,c as a,ai as n}from"./chunks/framework.Bm4BMKaq.js";const g=JSON.parse('{"title":"How Standard Library Works","description":"","frontmatter":{},"headers":[],"relativePath":"explanation/how-it-works/std/index.md","filePath":"explanation/how-it-works/std/index.md"}'),t={name:"explanation/how-it-works/std/index.md"};function s(r,e,l,d,c,h){return i(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="how-standard-library-works" tabindex="-1">How Standard Library Works <a class="header-anchor" href="#how-standard-library-works" aria-label="Permalink to “How Standard Library Works”">​</a></h1><p>How the standard library components.</p><h2 id="concepts" tabindex="-1">Concepts <a class="header-anchor" href="#concepts" aria-label="Permalink to “Concepts”">​</a></h2><h3 id="short-circuit-behavior" tabindex="-1">Short-Circuit Behavior <a class="header-anchor" href="#short-circuit-behavior" aria-label="Permalink to “Short-Circuit Behavior”">​</a></h3><p>Global options with handlers (like <code>--help</code> and <code>--version</code>) short-circuit the execution pipeline. When <code>executeCommand()</code> finds a global option present in parsed args with a handler, it calls the handler and <strong>returns immediately</strong> — skipping validation, plugin hooks, and the command handler entirely.</p><h2 id="plugins" tabindex="-1">Plugins <a class="header-anchor" href="#plugins" aria-label="Permalink to “Plugins”">​</a></h2><p>The standard library consists of a small set of focused plugins:</p><h3 id="helpplugin" tabindex="-1"><code>helpPlugin</code> <a class="header-anchor" href="#helpplugin" aria-label="Permalink to “helpPlugin”">​</a></h3><p>Uses <code>onInit</code> to mutate the CLI structure:</p><ul><li><strong>No root command exists</strong> — creates one with help command as default handler and injects <code>help</code> subcommand</li><li><strong>Root command exists</strong> — preserves existing definition and appends <code>help</code> subcommand</li></ul><p>Adds <code>--help</code> / <code>-h</code> global option that short-circuits to render command-specific help.</p><h3 id="versionplugin" tabindex="-1"><code>versionPlugin</code> <a class="header-anchor" href="#versionplugin" aria-label="Permalink to “versionPlugin”">​</a></h3><p>Uses <code>onInit</code> to mutate the CLI structure:</p><ul><li><strong>No root command exists</strong> — creates one (with help as fallback) and injects <code>version</code> subcommand, merging <code>--version</code> into root options</li><li><strong>Root command exists</strong> — preserves existing definition, appends <code>version</code> subcommand, and merges <code>--version</code> into existing options</li></ul><h3 id="configplugin" tabindex="-1"><code>configPlugin</code> <a class="header-anchor" href="#configplugin" aria-label="Permalink to “configPlugin”">​</a></h3><p>Registers the std <code>config</code> global option on the CLI:</p><ul><li>Adds <code>--config</code> / <code>-c</code> as a global option</li><li>Lets users point the CLI at an explicit JSON config file</li></ul><p>The option handler then:</p><ul><li>Looks for config files in precedence order (explicit → local → global): <ul><li>Checks explicit path if <code>--config</code> is provided</li><li>If not found, checks local (cwd) using <code>defaultFilename</code> or <code>&lt;cli-name&gt;.config.json</code></li><li>If not found, checks global (OS-specific location)</li><li>Uses the <strong>first file that exists</strong> (no merging between files)</li></ul></li><li>Merges the matched file config with <code>defaultConfig</code>: <ul><li>File config takes precedence over <code>defaultConfig</code></li><li>If no file exists, uses <code>defaultConfig</code> (defaults to <code>{}</code>)</li></ul></li><li>Validates against <code>schema</code> if provided</li><li>Exposes the result on the context: <ul><li><code>context.config</code> — merged configuration object (always defined, at least <code>{}</code>)</li><li><code>context.configFiles</code> — list of <code>{ path, scope }</code> for the loaded file (scope is <code>&quot;explicit&quot; | &quot;local&quot; | &quot;global&quot;</code>)</li></ul></li></ul><p>Note: The plugin does not merge multiple config files. It uses the first file that exists in the precedence order. For merging behavior, use the <code>resolveConfig</code> service directly.</p><h2 id="services" tabindex="-1">Services <a class="header-anchor" href="#services" aria-label="Permalink to “Services”">​</a></h2><h3 id="helpservice" tabindex="-1"><code>helpService</code> <a class="header-anchor" href="#helpservice" aria-label="Permalink to “helpService”">​</a></h3><p><code>showHelp()</code> dispatches based on whether a command name is provided:</p><ul><li><strong>Root help</strong> — prints usage, version, description, lists subcommands with paths and deprecation warnings</li><li><strong>Command help</strong> — searches command tree by name or path, prints usage, aliases, positional, subcommands, options (merged with global options), and examples</li></ul><p>Option rendering reads Zod internals for aliases, descriptions, and deprecation flags — the same metadata the manifest layer extracts.</p><h3 id="versionservice" tabindex="-1"><code>versionService</code> <a class="header-anchor" href="#versionservice" aria-label="Permalink to “versionService”">​</a></h3><p><code>showVersion()</code> reads <code>cli.manifest.version</code> and prints it. If no version is set, it throws. The <code>--version</code> global option and <code>version</code> subcommand both delegate to this function.</p>',27)])])}const u=o(t,[["render",s]]);export{g as __pageData,u as default};
