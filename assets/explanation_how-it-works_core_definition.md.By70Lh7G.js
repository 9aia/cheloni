import{_ as a,o,c as i,ai as t}from"./chunks/framework.Bm4BMKaq.js";const m=JSON.parse('{"title":"How Definition Works","description":"","frontmatter":{},"headers":[],"relativePath":"explanation/how-it-works/core/definition.md","filePath":"explanation/how-it-works/core/definition.md"}'),n={name:"explanation/how-it-works/core/definition.md"};function s(d,e,r,c,h,l){return o(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="how-definition-works" tabindex="-1">How Definition Works <a class="header-anchor" href="#how-definition-works" aria-label="Permalink to “How Definition Works”">​</a></h1><p>How the definition layer works — identity functions, type inference, and Zod integration.</p><h2 id="identity-functions" tabindex="-1">Identity Functions <a class="header-anchor" href="#identity-functions" aria-label="Permalink to “Identity Functions”">​</a></h2><p>The <code>define*</code> functions are identity functions. They return the exact same object they receive. Their only purpose is to provide type inference so the user gets autocomplete and type-checking without manual annotations.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>defineCommand({ ... }) → same object, but now TypeScript knows its shape</span></span></code></pre></div><p>This means definitions are plain objects with no hidden state, no classes, no prototype chains. They can be composed, spread, and passed around freely.</p><h2 id="type-generics" tabindex="-1">Type Generics <a class="header-anchor" href="#type-generics" aria-label="Permalink to “Type Generics”">​</a></h2><p><code>CommandDefinition</code> carries two type parameters: <code>TPositionalDefinition</code> and <code>TOptionsDefinition</code>. These capture the exact Zod schema types the user provides:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>defineCommand({</span></span>
<span class="line"><span>  positional: z.string(),            → TPositionalDefinition = z.ZodString</span></span>
<span class="line"><span>  options: z.object({ v: z.boolean() }) → TOptionsDefinition = z.ZodObject&lt;{ v: z.ZodBoolean }&gt;</span></span>
<span class="line"><span>})</span></span></code></pre></div><p>These generics propagate through creation and into the handler, where <code>z.infer&lt;T&gt;</code> extracts the runtime types. The handler receives <code>positional: string</code> and <code>options: { v: boolean }</code> without any manual typing.</p><h2 id="root-commands" tabindex="-1">Root Commands <a class="header-anchor" href="#root-commands" aria-label="Permalink to “Root Commands”">​</a></h2><p><code>RootCommandDefinition</code> is <code>CommandDefinition</code> with <code>name</code> omitted. <code>defineRootCommand()</code> adds <code>name: &quot;root&quot;</code> automatically, so the user never needs to name the root.</p><h2 id="maybearray-normalization" tabindex="-1"><code>MaybeArray</code> Normalization <a class="header-anchor" href="#maybearray-normalization" aria-label="Permalink to “MaybeArray Normalization”">​</a></h2><p>Most array fields (<code>command</code>, <code>plugin</code>, <code>middleware</code>, <code>globalOption</code>) accept <code>MaybeArray&lt;T&gt;</code> — either a single value or an array. This is normalized to an array via <code>normalizeMaybeArray()</code> at the creation layer, not at definition time. Definitions store the value as-is.</p><h2 id="zod-as-the-schema-layer" tabindex="-1">Zod as the Schema Layer <a class="header-anchor" href="#zod-as-the-schema-layer" aria-label="Permalink to “Zod as the Schema Layer”">​</a></h2><p>Positional and options are raw Zod schemas — not wrappers, not adapters. The definition stores the schema directly, and downstream layers (<code>manifest</code>, <code>creation</code>, <code>execution</code>) read from it. This is what makes the entire type inference chain work: the Zod type is the single source of truth from definition to handler.</p><p>Metadata like <code>description</code>, <code>alias</code>, and <code>deprecated</code> is embedded in the schema via <code>.meta()</code> or <code>.describe()</code>, and later extracted by the manifest layer through Zod&#39;s <code>_def</code> internals.</p>`,17)])])}const f=a(n,[["render",s]]);export{m as __pageData,f as default};
