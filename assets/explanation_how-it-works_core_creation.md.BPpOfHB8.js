import{_ as o,o as i,c as a,ai as n}from"./chunks/framework.Bm4BMKaq.js";const h=JSON.parse('{"title":"How Creation Works","description":"","frontmatter":{},"headers":[],"relativePath":"explanation/how-it-works/core/creation.md","filePath":"explanation/how-it-works/core/creation.md"}'),t={name:"explanation/how-it-works/core/creation.md"};function d(c,e,s,l,r,m){return i(),a("div",null,[...e[0]||(e[0]=[n(`<h1 id="how-creation-works" tabindex="-1">How Creation Works <a class="header-anchor" href="#how-creation-works" aria-label="Permalink to “How Creation Works”">​</a></h1><p>How definitions are turned into runtime objects and how plugin <code>onInit</code> hooks run.</p><h2 id="runtime-objects" tabindex="-1">Runtime Objects <a class="header-anchor" href="#runtime-objects" aria-label="Permalink to “Runtime Objects”">​</a></h2><p>Each definition type produces a runtime object that wraps the original definition alongside its extracted manifest:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>CliDefinition       → Cli       { manifest, command, plugins, globalOptions }</span></span>
<span class="line"><span>CommandDefinition   → Command   { definition, manifest, commands, paths, deprecated }</span></span>
<span class="line"><span>PluginDefinition    → Plugin    { definition, manifest }</span></span>
<span class="line"><span>GlobalOptionDef     → GlobalOption { definition, manifest }</span></span></code></pre></div><h2 id="cli-creation" tabindex="-1">CLI Creation <a class="header-anchor" href="#cli-creation" aria-label="Permalink to “CLI Creation”">​</a></h2><p><code>createCli()</code> is the main orchestrator. It runs in this order:</p><ol><li>Extracts the CLI manifest via <code>getCliManifest()</code></li><li>Creates the root command tree (if a command definition is provided)</li><li>Creates global options from <code>globalOptions</code></li><li>Creates plugins from <code>plugins</code> and <code>pluginpacks</code></li><li>Assembles the <code>Cli</code> object</li><li>Runs <code>onInit</code> hooks for each plugin, passing the <code>Cli</code> object</li></ol><p>If any <code>onInit</code> hook throws, creation fails immediately — the error is logged and re-thrown.</p><h2 id="command-tree" tabindex="-1">Command Tree <a class="header-anchor" href="#command-tree" aria-label="Permalink to “Command Tree”">​</a></h2><p><code>createCommand()</code> builds the command tree recursively. For each command definition:</p><ol><li>Reads <code>commands</code></li><li>Calls <code>createCommand()</code> for each child definition</li><li>Stores children in a <code>ManifestKeyedMap</code> keyed by <code>manifest.name</code></li><li>Extracts the command manifest via <code>getCommandManifest()</code></li><li>Resolves <code>paths</code> — defaults to <code>[definition.name]</code> if none provided</li></ol><p><code>createRootCommand()</code> is a thin wrapper that adds <code>name: &quot;root&quot;</code> and delegates to <code>createCommand()</code>.</p><h2 id="manifestkeyedmap" tabindex="-1"><code>ManifestKeyedMap</code> <a class="header-anchor" href="#manifestkeyedmap" aria-label="Permalink to “ManifestKeyedMap”">​</a></h2><p>Collections of commands, plugins, and global options use <code>ManifestKeyedMap</code> — a <code>Map</code>-backed collection that derives the key from each item via its <code>manifest.name</code> property. It provides:</p><ul><li>Uniqueness enforcement — adding a duplicate key overwrites the previous value</li><li>Key-based lookup via <code>.get(key)</code></li><li>Iteration via <code>.values()</code> or <code>for...of</code></li><li>Convenient <code>.set(value)</code> method that automatically uses <code>value.manifest.name</code> as the key</li></ul><p>This is what allows <code>cli.plugins</code>, <code>cli.globalOptions</code>, and <code>command.commands</code> to be both iterable and key-addressable.</p><h2 id="plugin-oninit-mutation" tabindex="-1">Plugin <code>onInit</code> Mutation <a class="header-anchor" href="#plugin-oninit-mutation" aria-label="Permalink to “Plugin onInit Mutation”">​</a></h2><p>After the <code>Cli</code> object is assembled, <code>onInit</code> hooks run in insertion order. Hooks receive <code>{ cli, plugin }</code> and can mutate the CLI directly:</p><ul><li>Replace <code>cli.command</code> with a new command tree</li><li>Add items to <code>cli.globalOptions</code></li><li>Modify <code>cli.plugins</code></li></ul><p>The standard library plugins use this to inject <code>help</code> and <code>version</code> commands and global options. See <a href="./../../../guides/advanced/creating-plugins.html">Creating Plugins</a>.</p>`,21)])])}const u=o(t,[["render",d]]);export{h as __pageData,u as default};
