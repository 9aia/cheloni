import{_ as a,o as n,c as i,ai as s}from"./chunks/framework.Bm4BMKaq.js";const u=JSON.parse('{"title":"How Core Works","description":"","frontmatter":{},"headers":[],"relativePath":"explanation/how-it-works/core/index.md","filePath":"explanation/how-it-works/core/index.md"}'),t={name:"explanation/how-it-works/core/index.md"};function o(r,e,l,c,p,d){return n(),i("div",null,[...e[0]||(e[0]=[s(`<h1 id="how-core-works" tabindex="-1">How Core Works <a class="header-anchor" href="#how-core-works" aria-label="Permalink to “How Core Works”">​</a></h1><p>Core structure and data flow.</p><h2 id="layers" tabindex="-1">Layers <a class="header-anchor" href="#layers" aria-label="Permalink to “Layers”">​</a></h2><p>Cheloni has four layers, each transforming the output of the previous one:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Definition (plain objects with Zod schemas)</span></span>
<span class="line"><span>    ↓ extract metadata</span></span>
<span class="line"><span>Manifest (serializable metadata for help/introspection)</span></span>
<span class="line"><span>    ↓ build runtime objects</span></span>
<span class="line"><span>Creation (runtime instances with definition + manifest)</span></span>
<span class="line"><span>    ↓ resolve, parse, validate, run</span></span>
<span class="line"><span>Execution (command pipeline)</span></span></code></pre></div><ul><li><a href="./definition.html">How Definition Works</a> - Identity functions, type generics, Zod as the schema layer</li><li><a href="./manifest.html">How Manifest Works</a> - Metadata extraction from Zod internals, recursive traversal</li><li><a href="./creation.html">How Creation Works</a> - Runtime object construction, command tree, <code>ManifestKeyedMap</code>, plugin <code>onInit</code></li><li><a href="./execution.html">How Execution Works</a> - Routing, parsing, middleware, validation, handler pipeline</li></ul><h2 id="type-inference" tabindex="-1">Type Inference <a class="header-anchor" href="#type-inference" aria-label="Permalink to “Type Inference”">​</a></h2><p>Types flow from Zod schemas through all layers:</p><ol><li><strong>Definition</strong> — the user provides a Zod schema (e.g. <code>z.object({ verbose: z.boolean() })</code>) as <code>options</code>. <code>CommandDefinition&lt;TPositional, TOptions&gt;</code> captures the exact Zod types as generics.</li><li><strong>Creation</strong> — the generics are preserved on the <code>Command</code> runtime object.</li><li><strong>Execution</strong> — <code>CommandHandlerParams</code> uses <code>z.infer&lt;T&gt;</code> on the definition generics to produce the runtime types. The handler receives <code>options: { verbose: boolean }</code> without any manual annotation.</li></ol><h2 id="file-structure" tabindex="-1">File Structure <a class="header-anchor" href="#file-structure" aria-label="Permalink to “File Structure”">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>core/</span></span>
<span class="line"><span>├── definition/     # Plain objects with Zod schemas</span></span>
<span class="line"><span>├── manifest/       # Metadata extraction from definitions</span></span>
<span class="line"><span>├── creation/       # Runtime object construction + plugin onInit</span></span>
<span class="line"><span>└── execution/      # Routing, parsing, validation, handler pipeline</span></span></code></pre></div>`,11)])])}const f=a(t,[["render",o]]);export{u as __pageData,f as default};
